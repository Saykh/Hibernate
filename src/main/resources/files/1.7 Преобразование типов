1.7 Преобразование типов

Например, как под капотом работает преобразование LocalDate (Java) в Date (SQL)? В случае с
JDBC мы делали это вручную. Ведь, например, в preparedStatement из JDBC мы не можем передать,
например, LocalDate тип.
В Hibernate же в классе Configuration есть List<BasicTypes> - список всех типов, который поддерживает
Hibernate,и он может поддерживать один тип в другой.
И этот интерфейс BasicType наследуется от Type - самый главный интерфейс для всех типов в Hibernate.
И у него есть реализации StringType, IntegerType, LocalDateType, TimeStampTime, ManyToOne, CollectionType
и т.д. - все эти типы поддерживает Hibernate и он может преобразовывать  один в другой.
И мы не можем придумать свой тип и без доп кода добиться, чтобы, например, Hibernate преобразовал
в соответствующий SQL тип.

Если мы хотим СОЗДАТЬ СВОЙ тип данных, нам нужно реализовать интерфейс Type - но он сложен для
реализации, ибо там много методов, которые нужно реализовать - или облегченный интерфейс UserType.
Но и там не всё так просто.

Один из примеров реализаций UserType - это EnumType. Он позволяет нам создавать любые собственные
Enum и Hibernate будет преобразовывать их в соотвествующие SQL.

Как мы знаем, Enum наследуется от базового класса Enum, который содержит в себе поля name и ordinal.
Ordinal не так круто использовать, ведь если изменится порядок в Enum, то в БД придется делать update.
Да и в БД это не красиво выглядит - числовое представление.

По умолчанию стоит использование Ordinal, поэтому для изменениня на строковое представление мы используем
аннотацию @Enumerated(EnumType.STRING) и меняем представление на строковое.

@Enumerated(EnumType.STRING)
private Role role;

1.8 Написание своего типа

На прошлой лекции мы узнали, как Hibernate преобразует Java типы в SQL типы и наоборот, используя соответствующие
реализации интерфейса Type, которые есть на все случаи жизни. Но всё же, как написать свой тип и использовать
его в качестве полей в сущности. И тут у нас есть два пути:

1. написать свою реализацию, реализовав интерфейс Type или UserType.
2. написать свой конвертор

И для последнего есть класс, который имплементит интерфейс Type - AttributeConverterTypeAdapter.
И чтобы он срабатывал нужно написать свой конвертор
