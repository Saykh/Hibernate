1.13 Жизненный цикл Entity

На предыдущей лекции мы прошли тему PersisterContext (First Level Cache), теперь мы знаем, что у каждого объекта Session
есть свойPersisterContext - который представляет собой ассоциативный массив, где ключом является id сущности и её
EntityPersister, а значением сама эта сущность.
И именно на основании PersisterContext определяется состояние нашей сущности, и оно может быть разным в зависимости
от сессии, потому, что с одной сессией сущность может быть проассоциирована, а с другой нет. А как ассоциировать с
PersisterContext мы знаем - мы обязаны сделать какой-то запрос в БД, иначе сущность не попадает в PersisterContext.

Отсюда вытекает жизненный цикл сущность, то есть то, как та или иная сущность ассоциирована с каждым конкретным объектом
типа Session.

У каждой сущность есть 4 состояния, в которые можно попасть вызвать соответствующий метод у объекта Session.

1. TRANSIENT -> мы просто создали нашу сущность. Наша сущность ни с какой сессией не проассоциирована.

User user = User.builder()
                    .username("edilova_at@mail.ru")
                    .firstname("Albina")
                    .lastname("Edilova")
                    .birthDate(new Birthday(LocalDate.of(1993,4,8)))
                    .role(Role.ADMIN)
                    .info("""
                            {
                                "name": "Albina",
                                "nick": "Khedar"
                            }
                            """)
                    .build();

2. Для того, что проассоциировать Transient сущность проассоциировать с сессией и её PersisterContext, мы должны
вызвать у сессии метод save или saveOrUpdate, и тогда её состояние переходит в состояние PERSISTENT, а Persistent означает,
что данная сущность проассоциирована с PersisterContext сессии. Опять же, в завимости от того, у какого объета session
мы вызвали данный метод. Именно для этой сессии эта сущность будет в состоянии Persistent.


Ещё у нас есть методы get и createQuery -> сущности, которые мы нашли с помощью данных методов тоже переходят в состояние
Persistent и помещаются в PersisterContext.


Кроме того, мы видели, что когда мы вызываем метод update наша сущность тоже переходила в состояние Persistent, но мы
видели, что там неявно выполнялся метод get - то есть мы обязаны получить эту сущность из БД, чтобы проассоциировать
данную сущность с PersisterContext, и далее уже выполнялся метод update.

3.В случае с delete наша сущность удаляется из PersisterContext (кэш) и переходит в стояние REMOVED и будет удалена из БД,
когда закроем сессию или вызовем метод flash.
Напомню, что у Hibernate отложенный вызов запросов, следовательно, если хотим раньше выполнить запрос на удаление, мы
должны выполнить метод flush или закрыть сессию.

4. И последнее состоянии DETACHED, в которое сущность может попасть при вызове методов evict, clear, close - то есть
удаляем нашу сущность из PersisterContext нашей сессии.

То есть DETACHED отличается Transient тем, что DETACHED сущность была когда-то проассоциирована с какой-то сессией, и
именно для неё она в DETACHED состоянии.

Но мы можем вернуть её в Persistent состояние, вызвав у сессии один из методов - saveOrUpdate, merge, update - но в любом
из этих случаях неявно вызывается метод get, чтобы получить сущность как она есть из БД, а потом уже проассоцировать её
с сущностью, которая у нас есть на уровне приложения.

И последнее, помни, что состоянии сущности меняется только для той сессии, у которой вызывается соответствующий метод.




