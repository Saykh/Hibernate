4.2 ManyToOne. Fetch Types

Если бы на предыдущей лекции достали нашего пользователя, то через LEFT JOIN он бы подтянул с собой компанию, но Left
работает не так быстро, как INNER. Кроме того, как быть, если мы хотим сделать запрос на получение компании?

Давайте сделаем INNER JOIN, но тогда пользователи, у которых нет компаний, будет отсеяны. Но если у нас на company_id
стоит NOT NULL, лучше сделать INNER JOIN.

    @ManyToOne(optional = false)
    @JoinColumn(name = "company_id")
    private Company company;

    @ManyToOne(optional = false) -> по умолчанию true. Ставим false, и тогда это будет NOT NULL ограничение, и тогда мы
    будем обязаны устанавливать company_id.

    session1.get(User.class, 1L);

    И вот мы видим INNER JOIN.


    А что насчёт отдельного запроса, чтобы достать компанию?


     @ManyToOne(optional = false, fetch = FetchType.LAZY)
     @JoinColumn(name = "company_id")
     private Company company;

    fetch = FetchType.LAZY -> по умолчанию в нашем случае EAGER.
    Для коллекций LAZY.

    Вот мы поменяли на LAZY. Делаем запрос на получение пользователя, и теперь мы не видим запроса на получение компании.
    В чём дело?

    Сделаем запрос, откроем debug.

    User user1 = session1.get(User.class, 1L);

    Мы видим, что компания всё же установлена, но мы видим не CompanyClass, а какой-то CompanyHibernateProxy$.
    Это всего-лишь прокси класс, который создаётся динамически во время выполнения, во время компиляции такого класса
    нет.
    Именно благодаря прокси  и их реализации у нас есть возможность инициализировать компанию только тогда, когда мы
    попросим поля у нашей сущности company.

    Теперь мы в дебаге видим и select на на компанию, в предыдущий раз его не было, потому что у нас переопределен метод
    toString, а в дебаге он вызывается для отображения.
    Исключим company из toString,  тогда  дебаг при отображении пользователя, не вызовет toString у company, ведь если
    мы вызываем toString у company мы также инициализируем прокси.

    @ToString(exclude = "company")
    public class User {

    }
    Попробуем снова.

    Теперь в дебаге не видим select в company.


    Но давайте сделаем запрос на получение имени компании - теперь мы видим select запрос в таблицу company.


    Некоторые итоги: в маппинге ManyToOne, но и в других есть fetchType, который позволяет нам сразу же получать сущности,
    на которые мы завязаны, делая либо INNER ИЛИ LEFT join (в зависимости от значения optional). Так мы можем
    эффективно оптимизировать запросы.
    Но с Lazy ининициализацией есть некоторые проблемы - так как мы можем инициализировать так коллекции, когда у нас
    есть доступ к текущей открытой сессии и транзакции, в которой мы заполняем запрос, иначе будет исключение
    LazyInitException.







