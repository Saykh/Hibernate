2.1-2.2 Логгирование

Написали приложение, развернули на удаленном сервере, и этим приложением пользуются пользователи, но если мы не будем
подключать никаких систем логгирования или метрик, то наше приложение будет черным ящиком, если что-то пойдет не так,
мы и не узнаем об этом, а если придется рещить проблемы - у нас нет никаких сообщений в логгах, поэтому из черного ящика
мы должны сделать белый ящик.

Для этого и предназначена система логгирования и метрик.

Логирование – сообщение, несущее какую-либо информацию.

Метрика – статистика о нашем приложении – например, какая нагрузка на приложение (Request Per Second), как часто
наш код обращается в БД, как долго пользователь ждёт ответа от вашего приложения как только он отправил запрос.
Таких статистик можно делать множество в зависимости от наших нужд.

Логирование черз System.out.println работает только пока вы разраб приложение, ибо консоль есть только в среде разработки,
но когда мы развернем наше приложение, там нет консоли, поэтому можно складывать логи в файлы, либо в БД.
Но в реальных приложениях отправляют какому-нибудь удаленному серверу, который занимается логгированием через соединение
TCP и это  приложение знает как анализировать логи, либо метрики.

Есть готовые фреймворки для логов и метрик.

Для логов ELK – ELASTICKSEARCH, LOGSTACH, KIBANA – ХРАНЕНИЕ, ПАРСИНГ ЛОГОВ И КАК view для отображения любых сообщений
программистам.

Для метрик – Prometheus, Grafana. Первый – анализирует метрики, можно прикрутить функционал отправки сообщения в случае
каких-то проблем.

Логов много - log4j, logback, jdk14l (из коробки Java), simple. Их много, и мы можем захотеть изменить систему
логгирования. Для этого у нас есть API slf4j, который в свою очередь использует тот логер, который мы ему поставляет.
Для некоторые из них нужен своего рода binding (адаптер) для работы с ними.

                    log4j
                   binding
                      |
                    API slf4j
                      |
                    application

Log Levels - придумали для простоты и поиска соответствующих сообщений.

1. TRACE
2. DEBUG
3. INFO
4. WARN
5. ERROR
6. FATAL

Подключим нужные зависимости:


implementation 'org.slf4j:slf4j-api:1.7.35'    Уже был у нас.

implementation 'org.slf4j:slf4j-log4j12:1.7.35' А вот соответствующий адаптер.


Каждый логер конфигурируется с помощью текстового файла - xml или properties.

Создадим конфиг файл log4j.xml

<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE log4j:configuration SYSTEM "log4j.dtd">

<log4j:configuration>

    <!-- Куда отправлять сообщения -->
    <appender name="console" class="org.apache.log4j.ConsoleAppender">
        <param name="target" value="System.out"/>

        <layout class="org.apache.log4j.PatternLayout">
            <param name="conversionPattern" value="[%d{HH:mm:ss,SSS}] %p [%c: %L] %m%n"/>
        </layout>
    </appender>

    <!-- Сам лог. Их может быть несколько -->
    <root>
        <level value="info"/>
        <appender-ref ref="console"/> <!-- Если их несколько, можно перечислить -->

    </root>

</log4j:configuration>




public class HibernateRunner {

    private static final Logger logger = LoggerFactory.getLogger(HibernateRunner.class);

В каждом классе нужно создавать отдельный логер.

