1.10 Методы UPDATE, DELETE, GET

Вернемся к нашему объекту Session и рассмотрим его методы UPDATE и DELETE. Ведь пока мы изучили
только save.
UPDATE -> обновление, если такого пользователя нет, он бросит исключение.

Кстати, у Hibernate отложенная отправка запроса - он максимально пытается оттянуть тот момент,
когда нужно открыть транзакцию и начать общение с БД. Это всё для оптимизации - чтобы мы могли
собрать, например, несколько запросов и отправить их вместе. Поэтому запрос выполнится тогда,
когда мы закомитим транзакцию или закроем сессию.


Если мы не хотим проверять, есть ли такой пользователей или нет, используем метод SaveOrUpdate.
Если такого пользователя не будет, он сохранит. Сначала же он сделает select запрос - есть ли такой
пользователь, а потом insert (если такого пользователя нет) в КАКОЙ-ТО момент времени, но точно
до закрытия транзакции. Та же история и с update, если указанный пользователь имеется.


DELETE -> удаление сущности, тоже по ID. Опять же, сначала select - есть ли такая сущность, делать
ли последующий запрос delete в какой-то момент времени до закрытия транзакции или во время нее,
то есть опять отложенный запрос.

Если удаляемой сущности нет, данный метод не бросит исключение.


GET -> получение сущности:

User userGet = session.get(User.class, "edilov_st@mail.ru");

Тут два важных момента:

1. Почему мы передаем ещё и сущность? Потому, что с таким идент-м могут быть разные сущности, поэтому
уникальный ключ, по которому в сессии получаем сущность - это два поля - класс сущности и идент-р.

2. Данный метод отличается от предыдущих тем, что тут происходит процесс преобразования уже из РМ в ООМ.
Всё опять работает под капотом с помощью Reflection API. И тут важную роль играет конструктор без параметров.

@Test
    void checkGetReflectionApi() throws SQLException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException {
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = preparedStatement.executeQuery();
        resultSet.getString("username");
        resultSet.getString("firstname");
        resultSet.getString("lastname");

        Class<User> clazz = User.class;
        Constructor<User> constructor = clazz.getConstructor();
        User user = constructor.newInstance();
        Field userNameField = clazz.getDeclaredField("username");
        userNameField.setAccessible(true);
        userNameField.set(user, resultSet.getString("username"));

        // И так по каждому полю. Проходимся по всем полям и устанавливаем значения из ResultSet.
    }

